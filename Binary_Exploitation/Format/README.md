# Format
拿到一支有 **string format vulnerability** 的程式碼，要利用這個漏洞把一個global integer改成1337。

要成功，一定要知道format function怎麼處理format string和parameter：
 1. format function可以傳入任意長度的parameter
 2. 做什麼事由format string控制
 3. parameter被直接(by value)或間接(by reference address)的push到stack上，等待遇到 ''%''字元時被pop出來

那麼，如果我寫一個沒有給參數卻允許傳入format string控制format function的程式碼：`printf(argv[1])`，會怎樣呢？

如果argv[1] =
 * "%d", "%u", "%x", 會把stack最上方的item裡的值pop出來，分別以decimal, unsigned decimal,或hexadecimal表示出來
 * "%s"：正常情況在被處理的時候，stack指到的地方存有字串的reference位址，把位址pop出來，用這位址去找對應的數值並當作字串印出來。但如果不給變數，會直接把stack pointer目前指到的當位址去找資料印出來
 * "%n"：正常情況：printf("hello%n", &var); 把length("hello") = 5寫入var裡。但是如果後面不給變數，會直接把目前有多少byte'''直接寫入stack pointer目前指到的位址'''！！
 * stack的長相：`printf("some string...", %d %d %x", a, b, &c);}}}`
```
stack top
...
<address of c>
<value of b>
<value of a>
<address of "some string...">
...
stack bottom
 ```
知道format function怎麼運作後，要怎麼更改某個的存在stack上的變數呢？
 1. 注意到原始碼中：`int *ptr = &secret;`，ptr已經把secret的位址存到stack裡了，所以如果我們知道secret的位址，那麼就能確認ptr被放在stack從上數來地幾個的地方。
 2. 請善用gdb, 使用`(gdb) p &secret`，可以得知secret位址
 3. 然後用`./format %08x.%08x.%08x.%08x.%08x.%08x....`，每用一次 %x 就會pop出一個然後以16進制印出值是多少，花一點時間找出是7個。那麼接下來只要把這個位址的值更改成1337即可。
 4. 記得剛剛說過的，呼叫`%n`會把目前這個字串在`%n`前的byte數目push進stack裡，所以把stack pop到我們要的位置(把前6個踢掉)，把輸入的字串長度湊到1337，再呼叫`%n`就會把1337存到那個位址囉。
  * 湊足1337byte: %<加多少>u.%08x.%08x.%08x.%08x.%08x.%n，使用6個`.`(1 byte)+5個%08x(8 byte) = 46，所以`加多少` = 1337-46 = 1291
 5. 輸入：`./format %1291u.%08x.%08x.%08x.%08x.%08x.%n`，成功把secret改成1337，給出了提升權限的shell。但是輸入`cat flag.txt` 被 permission denied, 開`id` 察看發現權限仍然不足，所以在輸入同樣的東西取的更高一層的shell。再開一次`id`發現權限足夠了，於是成功開啟：

 flag.txt，取得 flag = who_thought_%n_was_a_good_idea?

## 參考資料
 * [format-string-attack教學](https://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf)
